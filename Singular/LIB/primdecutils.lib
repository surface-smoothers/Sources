version="version primdecutils.lib 4.0.0.0 Sep_2014 "; //
category="Commutative Algebra";
info="
LIBRARY: primdecutils.lib   utils for primary decomposition

AUTHORS:  Gerhard Pfister, pfister@mathematik.uni-kl.de 
          Wolfram Decker, decker@math.uni-sb.de         
          Hans Schoenemann, hannes@mathematik.uni-kl.de 
          Santiago Laplagne, slaplagn@dm.uba.ar         
          Kai Dehmann, dehmann@mathematik.uni-kl.de
          Jakob Kroeker, kroeker@math.uni-hannover.de


PROCEDURES:
  primDecsAreEquivalent(L, K);        procedure for comparing the output of primary decompositions

  testPrimary(L,k);                   a simple intersection test for a primary decomposition

  removeRedundantPrimaryComponents(); 

  convListToPrimaryDecompFormat();    convert a flat list with ( primary comp c1 , radical(c1) .. cn, radical(cn))
                                      to a list of size n with pair entries ( primary component ci , radical(ci) )
  flattenPrimaryDecompList();         flatten a primary decomposition list
  analyzePrimaryDecomp();             check for embedded components

  testFactorPoly();                   check the outcome of factorize() for a polynomial.

  idealsEqual();                      tests if two ideals are equal using std()


";



///////////////////////////////////////////////////////////////////////////////
// convert a flat list with ( primary comp c1 , radical(c1) .. cn, radical(cn))
// to a list of size n with pair entries ( primary component ci , radical(ci) )
proc convListToPrimaryDecompFormat(list l)
{
   int i;
   list re,he;
   for(i=1;i<=size(l) div 2;i++)
   {
      he=l[2*i-1],l[2*i];
      re[i]=he;
   }
   return(re);
}
///////////////////////////////////////////////////////////////////////////////
//flatten a primary decomposition list to ( primary comp c1 , radical(c1) .. cn, radical(cn))
proc flattenPrimaryDecompList(list l)
{
   int i;
   list re;
   for(i=1;i<=size(l);i++)
   {
      re[2*i-1]=l[i][1];
      re[2*i]=l[i][2];
   }
   return(re);
}

///////////////////////////////////////////////////////////////////////////////

proc testFactorPoly(list act,poly p)
{
  ASSUME(1, hasFieldCoefficient(basering) );
  ASSUME(1, not isQuotientRing(basering) ) ;
  ASSUME(1, hasGlobalOrdering(basering) ) ;
  poly keep=p;

  int i;
  poly q=act[1][1]^act[2][1];
  for(i=2;i<=size(act[1]);i++)
  {
    q=q*act[1][i]^act[2][i];
  }
  q=1/leadcoef(q)*q;
  p=1/leadcoef(p)*p;
  if(p-q!=0)
  {
    "ERROR IN FACTOR, please inform the authors";
  }
}


static proc stdIdealsEqual( ideal k1, ideal k2)
{
  int j;
  if(size(k1)==size(k2))
  {
    for(j=1;j<=size(k1);j++)
    {
      if(leadexp(k1[j])!=leadexp(k2[j]))
      {
        return(0);
      }
    }
    attrib(k2,"isSB",1);
    if(size(reduce(k1,k2,1))==0)
    {
      return(1);
    }
  }
  return(0);
}


proc idealsEqual( ideal k, ideal j)
{
  return(stdIdealsEqual(std(k),std(j)));
}




static proc analyzePrimaryDecomp(list pr)
{
   ASSUME(1, hasFieldCoefficient(basering) );
   ASSUME(1, not isQuotientRing(basering) ) ;
   ASSUME(1, hasGlobalOrdering(basering) ) ;

   int ii,jj;
   for(ii=1;ii<=size(pr) div 2;ii++)
   {
      dim(std(pr[2*ii]));
      idealsEqual(pr[2*ii-1],pr[2*ii]);
      "===========================";
   }

   for(ii=size(pr) div 2;ii>1;ii--)
   {
      for(jj=1;jj<ii;jj++)
      {
         if(size(reduce(pr[2*jj],std(pr[2*ii],1)))==0)
         {
            "embedded Component";
            jj;
            ii;
         }
      }
   }
}



/////////////////////////////////////////////////////////////////////
//                                                                 //
//        A L G O R I T H M S   F O R   T E S T I N G              //
//                                                                 //
/////////////////////////////////////////////////////////////////////


proc testPrimary(list pr, ideal k)
"USAGE:   testPrimary(pr,k); pr a list, k an ideal.
ASSUME:  pr is the result of primdecGTZ(k) or primdecSY(k).
RETURN:  int, 1 if the intersection of the ideals in pr is k, 0 if not
EXAMPLE: example testPrimary; shows an example
"
{
   ASSUME(0, hasFieldCoefficient(basering) );
   ASSUME(0, not isQuotientRing(basering) ) ;
   ASSUME(0, hasGlobalOrdering(basering) ) ;

   int i;
   pr=flattenPrimaryDecompList(pr);
   ideal j=pr[1];
   for (i=2;i<=size(pr) div 2;i++)
   {
       j=intersect(j,pr[2*i-1]);
   }
   return(idealsEqual(j,k));
}
example
{ "EXAMPLE:";  
   LIB ("primdec.lib");
   echo = 2;
   ring  r = 32003,(x,y,z),dp;
   poly  p = z2+1;
   poly  q = z4+2;
   ideal i = p^2*q^3,(y-z3)^3,(x-yz+z4)^4;
   list pr = primdecGTZ(i);
   testPrimary(pr,i);
}


proc removeRedundantPrimaryComponents(list primdecResult)
"USAGE:   removeRedundantPrimaryComponents(L); L a primary decomposition 
RETURN:  an irredundant primary decomposition.
EXAMPLE: example removeRedundantPrimaryComponents; shows an example"
proc removeRedundantPrimaryComponents(list primdecResult)
{
   int i,j;

   i = 1;
   j = 1;
   while  ( i<=size(primdecResult) ) 
   {  
     ASSUME(1, i>0 &&  i<=size(primdecResult) );
     ASSUME(1, j>0 &&  j<=size(primdecResult) );

      if (i!=j)
      {
          if ( isSubModule( std(primdecResult[j][1]) , std(primdecResult[i][1]) ) )
          { 
              primdecResult[i] =  primdecResult[j];
              primdecResult = delete(primdecResult,j);
              j = j - 1; /*correct j due to deletion */
              if ( j<i )  {    i = i -1;   } /*correct i */
          }
      } 
      j = j + 1;
      if ( j > size(primdecResult) )
      {
         i = i + 1;
         j = 1;
      }
   }

   return (primdecResult);
}
example
{
  "EXAMPLE:";

  ring rng = 0,(x,y),dp;
  def L1 = list(list(ideal(x-1),ideal(x-1)),list(ideal(x-1),ideal(x-1)),list(ideal(y-2),ideal(y-2)));
  def L2 = list(list(ideal(x-1),ideal(x-1)),list(ideal(y-2),ideal(y-2)));
  L1;
  L2;
  ASSUME(0, primDecsAreEquivalent( L1, L2 ) );
}

/////////////////////////////////////////////////////////////////////
proc primDecsAreEquivalent(list L, list K)
"USAGE:   primDecsAreEquivalent(L,K); L,K list of ideals
RETURN:  integer, 1 if the lists are the same up to ordering and redundant components; 0 otherwise
EXAMPLE: example primDecsAreEquivalent; shows an example"
{
  L = removeRedundantPrimaryComponents(L);
  K = removeRedundantPrimaryComponents(K);
  int s1 = size(L);
  int s2 = size(K);
  if(s1!=s2)
    {
      return(0);
    }
  list L1, K1;
  int i,j,t;
  list N;
  for(i=1; i<=s1; i++)
    {
      L1[i]=std(L[i][2]);
      K1[i]=std(K[i][2]);
    }
  for(i=1; i<=s1; i++)
    {
      for(j=1; j<=s1; j++)
        {
          if(isSubModule(L1[i],K1[j]))
            {
              if(isSubModule(K1[j],L1[i]))
                {
                  for(t=1; t<=size(N); t++)
                    {
                      if(N[t]==j)
                        {
                          return(0);
                        }
                    }
                  N[size(N)+1]=j;
                }

            }
        }
    }
  if ( size(N) != s1 )
  {
     return(0);
  }
  return(1);
}
example
{
  "EXAMPLE:";
  LIB ("primdec.lib");
  echo = 2;
  ring  r = 0,(x,y),dp;
  ideal i = x2,xy;
  list L1 = primdecGTZ(I);
  list L2 = primdecSY(I);
  primDecsAreEquivalent(L1,L2);
}
